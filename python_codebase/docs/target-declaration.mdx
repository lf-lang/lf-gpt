title: Target Declaration
description: The target declaration and its parameters in Lingua Franca.

Every Lingua Franca program begins with a statement of this form:

```lf
    target <name> <parameters>
```

The `<name>` gives the name of some Lingua Franca target language, which is the language in which reactions are written. This is also the language of the program(s) generated by the Lingua Franca compiler. The target languages currently supported are C, C++, Python, TypeScript, and Rust. There is also a target CCpp that is just like the C target except that it uses a C++ compiler to compile the code, thereby allowing inclusion of C++ code.

# Summary of Parameters

A target specification may have optional parameters, the names and values of which depend on which specific target you are using. Each parameter is a key-value pair, where the supported keys are a subset of the following:

- [**auth**](#auth): A boolean specifying to apply authorization between RTI and federates when federated execution.
- [**build**](#build): A command to execute after code generation instead of the default compile command.
- [**build-type**](#build-type): One of Debug (the default), Release, RelWithDebInfo and MinSizeRel.
- [**cargo-dependencies**](#cargo-dependencies): (Rust only) list of dependencies to include in the generated Cargo.toml file.
- [**cargo-features**](#cargo-features): (Rust only) List of string names of features to include.
- [**cmake-include**](#cmake): List of paths to cmake files to guide compilation.
- [**compiler**](#compiler): A string giving the name of the target language compiler to use.
- [**compiler-flags**](#compiler-flags): An arrays of strings giving options to be passed to the target compiler.
- [**docker**](#docker): A boolean to generate a Dockerfile.
- [**external-runtime-path**](#external-runtime-path): Specify a pre-compiled external runtime library located to link to instead of the default.
- [**export-dependency-graph**](#export-dependency-graph): To export the reaction dependency graph as a dot graph (for debugging).
- [**fast**](#fast): A boolean specifying to execute as fast as possible without waiting for physical time to match logical time.
- [**files**](#files): An array of paths to files or directories to be copied to the directory that contains the generated sources.
- [**logging**](#logging): An indicator of how much information to print when executing the program.
- [**no-compile**](#no-compile): If true, then do not invoke a target language compiler. Just generate code.
- [**no-runtime-validation**](#no-runtime-validation): If true, disable runtime validation.
- [**protobufs**](#protobufs): An array of .proto files that are to be compiled and included in the generated code.
- [**runtime-version**](#runtime-version): Specify which version of the runtime system to use.
- [**rust-include**](#rust-include): (Rust only) A set of Rust modules in the generated project.
- [**scheduler**](#scheduler): (C only) Specification of the scheduler to us.
- [**single-file-project**](#single-file-project): (Rust only) If true, enables [single-file project layout](#single-file-layout).
- [**single-threaded**](#single-threaded): Specify to not use multithreading.
- [**timeout**](#timeout): A time value (with units) specifying the logical stop time of execution. See [Termination](../writing-reactors/termination.mdx).
- [**workers**](#workers): If using multiple threads, how many worker threads to create.

Not all targets support all target parameters. The full set of target parameters supported by the target is:

c={
`target C {
    auth: <true or false>
    build: <string>,
    build-type: <Debug, Release, RelWithDebInfo, or MinSizeRel>,
    cmake-include: <string or list of strings>,
    compiler: <string>,
    compiler-flags: <string or list of strings>,
    docker: <true or false>,
    fast: <true or false>,
    files: <string or list of strings>,
    logging: <error, warning, info, log, debug>,
    no-compile: <true or false>,
    protobufs: <string or list of strings>,
    single-threaded: <true or false>,
    timeout: <time>,
    workers: <non-negative integer>,
};`
} 
cpp={
`target Cpp {
    build-type: <Debug, Release, RelWithDebInfo, or MinSizeRel>,
    cmake-include: <string or list of strings>,
    compiler: <string>,
    external-runtime-path: <string>,
    export-dependency-graph <true or false>,
    fast: <true or false>,
    logging: <error, warning, info, log, debug>,
    no-compile: <true or false>,
    no-runtime-validation: <true or false>,
    runtime-version: <string>,
    timeout: <time>,
    workers: <non-negative integer>,
};`
} 
py={
`target Python {
    docker: <true or false>,
    fast: <true or false>,
    files: <string or list of strings>,
    logging: <error, warning, info, log, debug>,
    no-compile: <true or false>,
    protobufs: <string or list of strings>,
    single-threaded: <true or false>,
    timeout: <time>,
    workers: <non-negative integer>,
};`
} 
rs={
`target Rust {
    build-type: <Debug, Release, RelWithDebInfo, or MinSizeRel>,
    cargo-features: <array of strings>,
    cargo-dependencies: <list of key-value pairs>,
    export-dependency-graph: <true or false>,
    rust-include: <array of strings>,
    single-file-project: <true or false>,
    single-threaded: <true or false>,
    timeout: <time value>,
}`
} 
ts={
`target TypeScript {
    docker: <true or false>,
    fast: <true or false>,
    logging: <ERROR, WARN, INFO, LOG, or DEBUG>,
    timeout: <time>,
};`
} />


For example:

```lf-c
target C {
    cmake: false,
    compiler: "cc",
    fast: true,
    logging: log,
    timeout: 1 secs,
};
```

This specifies to use compiler `cc` instead of the default `gcc`, to use optimization level 3, to execute as fast as possible, and to exit execution when logical time has advanced to 10 seconds. Note that all events at logical time 10 seconds greater than the starting logical time will be executed.


The comma on the last parameter is optional, as is the semicolon on the last line.
A target may support overriding the target parameters on the [command line](#command-line-arguments) when invoking the compiled program.

## auth


## build



## build-type



## cargo-dependencies


## cargo-features



## cmake-include

```lf-c
target C {
    cmake-include: ["relative/path/to/foo.txt", "relative/path/to/bar.txt", ...]
};
```

```lf-cpp
target Cpp {
    cmake-include: ["relative/path/to/foo.txt", "relative/path/to/bar.txt", ...]
};
```

This will optionally append additional custom CMake instructions to the generated `CMakeLists.txt`, drawing these instructions from the specified text files (e.g, `foo.txt`). The specified files are resolved using the same file search algorithm as used for the [files](#files) target parameter. Those files will be copied into the `src-gen` directory that contains the generated sources. This is done to make the generated code more portable<span class="lf-c"> (a feature that is useful in [federated execution](../writing-reactors/distributed-execution.mdx))</span>.

The cmake-include target property can be used, for example, to add dependencies on various packages (e.g., by using the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html) and [`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html) commands).

A CMake variable called `${LF_MAIN_TARGET}` can be used in the included text file(s) for convenience. This variable will contain the name of the CMake target (i.e., the name of the main reactor). For example, a `foo.txt` file can contain:

```cmake
find_package(m REQUIRED) # Finds the m library

target_link_libraries( ${LF_MAIN_TARGET} m ) # Links the m library
```

`foo.txt` can then be included by specifying it as an argument to `cmake-include`.

**Note**: For a general tutorial on finding packages in CMake, see [this](https://cmake.org/cmake/help/latest/command/find_package.html) external documentation entry. For a list of CMake find modules, see [this](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find-modules).

The `cmake-include` parameter works in conjunction with the `import` statement. If any imported `.lf` file has `cmake-include` among its target properties, the specified text files will be appended to the current list of `cmake-include`s. These files will be resolved relative to the imported `.lf` file using the same search procedure as for the [files](#files) parameter. This helps resolve dependencies in imported reactors automatically and makes the code more modular.


[CMakeInclude.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/CMakeInclude.lf) is an example that uses this feature. A more sophisticated example of the usage of this target parameter can be found in [Rhythm.lf](https://github.com/lf-lang/examples-lingua-franca/blob/main/C/src/Rhythm/Rhythm.lf). A distributed version can be found in [DistributedCMakeInclude.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/DistributedCMakeInclude.lf) is a test that uses this feature.

**Note**: For [federated execution](../writing-reactors/distributed-execution.mdx), both `cmake-include` and [files](#files) are kept separate for each federate as much as possible. This means that if one federate is imported, or uses an imported reactor that other federates don't use, it will only have access to `cmake-include`s and `files` defined in the main `.lf` file, plus the selectively imported `.lf` files. [DistributedCMakeIncludeSeparateCompile.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/DistributedCMakeIncludeSeparateCompile.lf) is a test that demonstrates this feature.



See [`AsyncCallback.lf`](https://github.com/lf-lang/lingua-franca/blob/master/test/Cpp/src/concurrent/AsyncCallback.lf) for an example.



## compiler


## docker


## external-runtime-path


## export-dependency-graph


## fast

By default, the execution of a Lingua Franca program is slowed down, if necessary, so that logical time does not elapse faster than physical time. If you wish to execute the program as fast as possible without this constraint, then specify the `fast` target parameter with value `true`.

## files


## logging



## no-compile



## no-runtime-validation


## protobufs


## runtime-version


## rust-include


## scheduler


## single-file-project


## single-threaded


The Python target uses the single threaded C runtime by default but will switch to the multithreaded C runtime if a physical action is detected. This target property can be used to override this behavior.

## timeout

A time value (with units) specifying the logical stop time of execution. See [Termination](../writing-reactors/termination.mdx).

## workers


This parameter takes a non-negative integer and specifies the number of worker threads to execute the generated program. Note, however, that the Python core is unable to execute safely in parallel on multiple cores. As a consequence, at execution time, each reaction invocation will acquire a mutual exclusion lock before executing. Hence, there is little point in setting this to any number greater than `1`.

# Command-Line Arguments


The Python target does not currently support any command-line arguments. You must specify properties as target parameters.


