title: Target Language Details
description: Detailed reference for each target langauge.

[comment]: <> (================= NEW SECTION =====================)

## Overview



In the Python reactor target for Lingua Franca, reactions are written in Python. The user-written reactors are then generated into a Python 3 script that can be executed on several platforms. The Python target has been tested on Linux, macOS, and Windows. To facilitate efficient and fast execution of Python code, the generated program relies on a C extension to facilitate Lingua Franca API such as `set` and `schedule`. To learn more about the structure of the generated Python program see [Implementation Details](#target-implementation-details).

Python reactors can bring the vast library of scientific modules that exist for Python into a Lingua Franca program. Moreover, since the Python reactor target is based on a fast and efficient C runtime library, Lingua Franca programs can execute much faster than native equivalent Python programs in many cases. Finally, interoperability with C reactors is planned for the future.

In comparison to the C target, the Python target can be up to an order of magnitude slower. However, depending on the type of application and the implementation optimizations in Python, you can achieve an on-par performance to the C target in many applications.

**NOTE:** A [Python C
extension](https://docs.python.org/3/extending/extending.html) is
generated for each Lingua Franca program (see [Implementation
Details](#target-implementation-details)). This extension module will
have the name LinguaFranca[your_LF_program_name].

[comment]: <> (================= NEW SECTION =====================)

## Requirements



To use this target, install Python 3 on your machine. See [downloading Python](https://wiki.python.org/moin/BeginnersGuide/Download).

**NOTE:** The Python target requires a C implementation of Python (nicknamed CPython). This is what you will get if you use the above link, or with most of the alternative Python installations such as Anaconda. See [Python download alternatives](https://www.python.org/download/alternatives/) for more details.

The Python reactor target relies on `setuptools` to be able to compile a [Python
C extension](https://docs.python.org/3/extending/extending.html) for each LF
program.

\<!-- To install `pip3`, you can follow instructions [here](https://pip.pypa.io/en/stable/installation/). -->

To install `setuptools` using `pip3`, do this:

```sh
pip3 install setuptools
```

[comment]: <> (================= NEW SECTION =====================)

## Limitations



- The Lingua Franca lexer does not support single-quoted strings in Python. This limitation also applies to target property values. You must use double quotes.

[comment]: <> (================= NEW SECTION =====================)

## The Target Specification



To have Lingua Franca generate Python code, start your `.lf` file with the following target specification:

```lf
    target Python
```

Note that for all LF statements, a final semicolon is optional.

For options to the target specification, see [detailed documentation of the target options](../introduction.md).

[comment]: <> (================= NEW SECTION =====================)

## Parameters and State Variables



Reactor parameters and state variables are referenced in the Python code using
the syntax `self.<name>`, where `<name>` is the name of the parameter or state
variable. The following
[Stride](https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/Stride.lf)
example modifies the `Count` reactor in [State Declaration](<../writing-reactors/parameters-and-state-variables.mdx#state-declaration>) to
include both a parameter and a state variable:

```lf-py
reactor Count(stride=1) {
  state count = 1
  output y
  timer t(0, 100 msec)
  reaction(t) -> y {=
    y.set(self.count)
    self.count += self.stride
  =}
}
```

This defines a `stride` parameter with initial value `1` and a `count` state
variable with the same initial value. These are referenced in the reaction with
the syntax `self.stride` and `self.count` respectively. Note that state
variables and parameters do not have types in the Python reactor target. See [Parameters and State](../writing-reactors/parameters-and-state-variables.mdx) for more examples.

**The Reactor Class:**
The code generator synthesizes a class in Python for each reactor class in LF,
with a constructor (i.e., `def __init__(self, ...):`) that creates an instance
of this class and initializes its parameters and state variables as [instance
variables](https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables).
These parameters and state variables can then subsequently be accessed directly
using the `self` reference in the body of reactions.

It may be tempting to declare state variables in the `preamble`, as follows:

```lf-py
reactor FlawedCount {
  preamble {=
    count = 0
  =}
  output y
  timer t(0, 100 msec)
  reaction(t) -> y {=
    y.set(count)
    count += 1
  =}
}
```

This will produce a sequence of integers, but if there is more than one instance
of the reactor, those instances will share the same variable `count` (because
`count` will be a [class variable](https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables)). Hence,
**don't do this**! Sharing variables across instances of reactors violates a
basic principle, which is that reactors communicate only by sending messages to
one another. Sharing variables will make your program nondeterministic. If you
have multiple instances of the above `FlawedCount` reactor, the outputs produced
by each instance will not be predictable, and in a multithreaded implementation,
will also not be repeatable.

### Array Expressions for State Variables and Parameters

Array parameters and state variables are implemented using Python lists and initialized using a parentheized list. In the following example, the
parameter `sequence` and the state variable `x` have an initial value that is a Python list `[1, 2, 3]`:

```lf-py
reactor Foo(param = {= [1, 2, 3] =}) {
  state x = {= [1, 2, 3] =}
  ...
}
```

Their elements may be accessed as arrays in the body of a reaction, for example `self.x[i]`, where `i` is an array index.

The parameter may be overridden with a different list at instantiation:

```lf-py
main reactor {
  f = new Foo(param = {= [3, 4, 5, 6]} )
}
```

As with any ordinary Python list or tuple, `len()` can been used to deduce the
length. In the above, `len(self.x)` and `len(self.param)` will return the lengths of the two lists.

### Assigning Arbitrary Initial Expressions to State Variables and Parameters

As used for lists above, the code delimiters `{= ... =}` can allow for assignment of arbitrary Python
expressions as initial values for state variables and parameters. The following example, taken from
[StructAsState.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/StructAsState.lf)
demonstrates this usage:

```lf-py
main reactor StructAsState {
  preamble {=
    class hello:
      def __init__(self, name, value):
        self.name = name
        self.value = value
  =}
  state s = {= self.hello("Earth", 42) =}

  reaction(startup) {=
    # will print "State s.name="Earth", value=42."
    print("State s.name=\"{:s}\", value={:d}.".format(self.s.name, self.s.value))
  =}
}
```

Notice that a class `hello` is defined in the preamble. The state variable `s` is then initialized to an instance of `hello` constructed within the `{= ... =}` delimiters.

[comment]: <> (================= NEW SECTION =====================)

## Inputs and Outputs



In the body of a reaction in the Python target, the value of an input is
obtained using the syntax `name.value`, where `name` is the name of the input
port. To determine whether an input is present, use `name.is_present`. To
produce an output, use the syntax `name.set(value)`. The `value` can be any
valid Python object. For simple examples, see [Inputs and Outputs](../writing-reactors/inputs-and-outputs.mdx).

### Sending and Receiving Objects

You can define your own data types in Python and send and receive those. Consider the [StructAsType](https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/StructAsType.lf) example:

```lf-py
target Python {
  files: include/hello.py
}
preamble {=
  import hello
=}
reactor Source {
  output out;
  reaction(startup) -> out {=
    temp = hello.hello("Earth", 42)
    out.set(temp)
  =}
}
```

The top-level preamble has imported the [hello](https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/include/hello.py) module, which contains the following class:

```python
class hello:
    def __init__(self, name = "", value = 0):
        self.name = name
        self.value = value
```

In the reaction to **startup**, the reactor has created an instance object of this class (as local variable named `temp`) and passed it downstream using the `set` method on output port `out`.

The `set` method is defined as follows:

> `<port>.set(value)`: Set the specified output port (or input of a contained
> reactor) to the specified value. This value can be any Python object
> (including `None` and objects of type `Any`). The value is
> copied and therefore the variable carrying the value can be subsequently
> modified without changing the output.

A reactor receiving the class object message can subsequently access the object
using `<port>.value`:

```lf-py
reactor Print(expected(42)) {
  input _in;
  reaction(_in) {=
    print("Received: name = {:s}, value = {:d}\n".format(_in.value.name,
                                                         _in.value.value))
  =}
}
```

**Note:** The `hello` module has been imported using a top-level preamble, therefore, the contents of the module are available to all reactors defined in the current Lingua Franca file (a similar situation arises if the `hello` class itself was in the top-level preamble).

[comment]: <> (================= NEW SECTION =====================)

## Time



Timers are specified exactly as in the [Time and Timers](../writing-reactors/time-and-timers.mdx). When working with time in the Python code body of a reaction, however, you will need to know a bit about its internal representation.

In the Python target, similar to the C target, the value of a time instant or
interval is an integer specifying a number of nanoseconds. An instant is the
number of nanoseconds that have elapsed since January 1, 1970. An interval is
the difference between two instants.

The functions for working with time and tags are:

- `lf.tag() -> Tag`: Returns a Tag instance of the current tag at which this reaction has been invoked.
- `lf.tag_compare(Tag, Tag) -> int`: Compare two `Tag` instances, returning -1, 0, or 1 for less than, equal, and greater than. `Tag`s can also be compared using rich comparators (ex. `<`, `>`, `==`), which returns `True` or `False`.
- `lf.time.logical() -> int`: Get the current logical time (the first part of the current tag).
- `lf.time.logical_elapsed() -> int`: Get the logical time elapsed since program start.

`Tag`s can be initialized using `Tag(time=some_number, microstep=some_other_number)`.

There are also some useful functions for accessing physical time:

- `lf.time.physical() -> int`: Get the current physical time.
- `lf.time.physical_elapsed() -> int`: Get the physical time elapsed since program start.
- `lf.time.start() -> int`: Get the starting physical and logical time.

The last of these is both a physical and a logical time because, at the start of execution, the starting logical time is set equal to the current physical time as measured by a local clock.

A reaction can examine the current logical time (which is constant during the execution of the reaction). For example, consider the [GetTime.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/GetTime.lf) example:

```lf-py
main reactor GetTime {
  timer t(0, 1 sec);
  reaction(t) {=
    logical = lf.time.logical()
    print("Logical time is ", logical)
  =}
}
```

When executed, you will get something like this:

```
---- Start execution at time Thu Nov  5 08:51:02 2020
---- plus 864237900 nanoseconds.
Logical time is  1604587862864237900
Logical time is  1604587863864237900
Logical time is  1604587864864237900
...
```

The first two lines give the current time-of-day provided by the execution platform at the start of execution. This is used to initialize logical time. Subsequent values of logical time are printed out in their raw form, rather than the friendlier form in the first two lines. If you look closely, you will see that each number is one second larger than the previous number, where one second is 1000000000 nanoseconds.

You can also obtain the _elapsed_ logical time since the start of execution:

```lf-py
main reactor GetTime {
  timer t(0, 1 sec);
  reaction(t) {=
    elapsed = lf.time.logical_elapsed()
    print("Elapsed logical time is ", elapsed)
  =}
}
```

This will produce:

```
---- Start execution at time Thu Nov  5 08:51:02 2020
---- plus 864237900 nanoseconds.
Elapsed logical time is  0
Elapsed logical time is  1000000000
Elapsed logical time is  2000000000
...
```

You can also get physical time, which comes from your platform's real-time clock:

```lf-py
main reactor GetTime {
  timer t(0, 1 sec);
  reaction(t) {=
    physical = lf.time.physical()
    print("Physical time is ", physical)
  =}
}
```

This will produce something like this:

```
---- Start execution at time Thu Nov  5 08:51:02 2020
---- plus 864237900 nanoseconds.
Physical time is  1604587862864343500
Physical time is  1604587863864401900
Physical time is  1604587864864395200
...
```

Finally, you can get elapsed physical time:

```lf-py
main reactor GetTime {
  timer t(0, 1 sec);
  reaction(t) {=
    elapsed_physical = lf.time.physical_elapsed()
    print("Elapsed physical time is ", elapsed_physical)
  =}
}
```

This will produce something like this:

```
---- Start execution at time Thu Nov  5 08:51:02 2020
---- plus 864237900 nanoseconds.
Elapsed physical time is  110200
Elapsed physical time is  1000185400
Elapsed physical time is  2000178600
...
```

Notice that these numbers are increasing by roughly one second each time. If you set the `fast` target parameter to `true`, then logical time will elapse much faster than physical time.

Working with nanoseconds in the Python code can be tedious if you are interested in longer durations. For convenience, a set of functions are available to the Python programmer to convert time units into the required nanoseconds. For example, you can specify 200 msec in Python code as `MSEC(200)` or two weeks as `WEEKS(2)`. The provided functions are `NSEC`, `USEC` (for microseconds), `MSEC`, `SEC`, `MINUTE`, `HOUR`, `DAY`, and `WEEK`. You may also use the plural of any of these. Examples are given in the next section.

[comment]: <> (================= NEW SECTION =====================)

## Actions



Actions are described [here](../writing-reactors/actions.mdx). Actions can carry a
**value**, a Python object that becomes available to any reaction triggered by
the action. This is particularly useful for physical actions that are externally
triggered because it enables the action to convey information to the reactor.
This could be, for example, the body of an incoming network message or a
numerical reading from a sensor. Note that actions do not have a data
type in the Python target, even when they carry a value.

Recall from [Composing Reactors](../writing-reactors/composing-reactors.mdx) that the
`after` keyword on a connection between ports introduces a logical delay. This
is actually implemented using a logical action. We illustrate how this is done
using the
`Delay` reactor in the [DelayInt](https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/DelayInt.lf)
example:

```lf-py
reactor Delay(delay = 100 ms) {
  input _in
  output out
  logical action a
  reaction(a) -> out {=
    if (a.value is not None) and a.is_present:
      out.set(a.value)
  =}
  reaction(_in) -> a {=
    a.schedule(self.delay, _in.value)
  =}
}
```

Using this reactor as follows

```lf
    delay = new Delay()
    <source_port_reference> -> delay._in
    delay._in -> <destination_port_reference>
```

is equivalent to

```lf
    <source_port_reference> -> <destination_port_reference> after 100 ms
```

In the `Delay` reactor, the reaction to the input `_in` declares as its effect
the action `a`. This declaration makes it possible for the reaction to schedule
a future triggering of `a` using the
[`a.schedule()`](<../reference/target-language-details.mdx#schedule-functions>)
method.

The first reaction declares that it is triggered by `a` and has effect `out`. To
read the value, it uses the `a.value` syntax. Because this reaction is first,
the `out` at any logical time can be produced before the input `_in` is even
known to be present. Hence, this reactor can be used in a feedback loop, where
`out` triggers a downstream reactor to send a message back to `_in` of this same
reactor. If the reactions were given in the opposite order, there would be a
causality loop and compilation would fail.

If you are not sure whether an action carries a value, you can test for it as follows:

```lf-py
  reaction(a) -> out {=
    if (a.value is not None):
      out.set(a.value)
  =}
```

It is possible to both be triggered by and schedule an action in the same
reaction. For example, the
following [CountSelf](https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/CountSelf.lf)
reactor will produce a counting sequence after it is triggered the first time:

```lf-py
reactor CountSelf(delay = 100 ms) {
  output out
  logical action a
  reaction(startup) -> a, out {=
    out.set(0)
    a.schedule(self.delay, 1)
  =}
  reaction(a) -> a, out {=
    out.set(a.value)
    a.schedule(self.delay, a.value + 1)
  =}
}
```

Of course, to produce a counting sequence, it would be more efficient to use a state variable.

[comment]: <> (================= NEW SECTION =====================)

### Schedule Functions



The Python reactor target provides a `.schedule()` method to trigger an action at a
future logical time. The `.schedule()` method also optionally allows for a value
to be sent into the future. For example, take the
[ScheduleValue.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/Python/src/ScheduleValue.lf):

```lf-py
main reactor ScheduleValue {
  logical action a;
  reaction(startup) -> a {=
    value = "Hello"
    a.schedule(0, value)
  =}
  reaction(a) {=
    print("Received: ", a.value)
    if a.value != "Hello":
      sys.stderr.write("FAILURE: Should have received 'Hello'\n")
      exit(1)
  =}
}
```

In this example, the logical action `a` is scheduled one
[microstep](../writing-reactors/superdense-time.mdx) in the future with a string `value`
containing `"Hello"`.

[comment]: <> (================= NEW SECTION =====================)

## Stopping Execution



A reaction may request that the execution stop after all events with the current timestamp have been processed by calling the built-in method `lf.request_stop()`, which takes no arguments. In a non-federated execution, the actual last tag of the program will be one microstep later than the tag at which `lf.request_stop()` was called. For example, if the current tag is `(2 seconds, 0)`, the last (stop) tag will be `(2 seconds, 1)`. In a federated execution, however, the stop time will likely be larger than the current logical time. All federates are assured of stopping at the same logical time.

> The [timeout](<../writing-reactors/termination.mdx#timeout>) target property will take precedence over this function. For example, if a program has a timeout of `2 seconds` and `request_stop()` is called at the `(2 seconds, 0)` tag, the last tag will still be `(2 seconds, 0>)`.

[comment]: <> (================= NEW SECTION =====================)

## Log and Debug Information



The Python supports the [logging](<../introduction.md#logging>) target specification. This will cause the runtime to produce more or less information about the execution. However, user-facing functions for different logging levels are not yet implemented (see issue [#619](https://github.com/lf-lang/lingua-franca/issues/619)).

[comment]: <> (================= NEW SECTION =====================)

## Libraries Available to Programmers



:::warning
FIXME: Details needed here.
:::

[comment]: <> (================= NEW SECTION =====================)


## Scheduler Target Property


[comment]: <> (================= NEW SECTION =====================)

## Target Implementation Details



The Python target is built on top of the C runtime to enable maximum efficiency where possible. It uses the single-threaded C runtime by default but will switch to the multi-threaded C runtime if a physical action is detected. The [threading](<../introduction.md#threading>) target property can be used to override this behavior.

Running [lfc](../tools/command-line-tools.mdx) on a `XXX.lf` program that uses the Python target specification on a
Linux machine will create the following files (other operating systems will have
a slightly different structure and/or files):

```shell
├── src
│   └── XXX.lf
└── src-gen
    └── XXX
        ###### Files related to the Python C extension module for XXX ######
        ├── build               # Temporary files for setuptools
        ├── core                # Core C runtime files
        ├── ctarget.c           # C target API implementations
        ├── ctarget.h           # C target API definitions
        ├── LinguaFrancaXXX*.so # The Python C extension module for XXX
        ├── pythontarget.c      # Python target API implementations
        ├── pythontarget.h      # Python target API definitions
        ├── setup.py            # Setup file used to build the Python C extension
        ├── XXX.c               # Source code of the Python C extension
        ###### Files containing the Python code ######
        └── XXX.py              # Python file containing reactors and reaction code
```

There are two major components in the `src-gen/XXX` directory that together enable the execution of a Python target application:

- An [XXX.py](#the-xxxpy-file-containing-user-code) file containing the user code (e.g., reactor definitions and reactions).
- The source code for a [Python C extension module](#the-generated-linguafrancaxxx-python-module-a-c-extension-module) called `LinguaFrancaXXX` containing the C runtime, as well as hooks to execute the user-defined reactions.

The interactions between the `src-gen/XXX/XXX.py` file and the `LinguaFrancaXXX` module are explained [below](#interactions-between-xxxpy-and-linguafrancaxxx).

### The `XXX.py` file containing user code

The `XXX.py` file contains all the reactor definitions in the form of Python classes. The contents of a reactor are converted as follows:

- Each **Reaction** in a reactor definition will be converted to a class method.
- Each **Parameter** will be converted to a class [property](https://docs.python.org/3/library/functions.html?highlight=property#property) to make it read-only.
- Each **State** variable will be converted to an [instance variable](https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables).
- Each trigger and effect will be converted to an object passed as a method function argument to reaction methods, allowing the body of the reaction to access them.
- Each reactor **Preamble** will be put in the class definition verbatim.

Finally, each reactor class instantiation will be converted to a Python object class instantiation.

For example, imagine the following program:

```lf-py
# src/XXX.lf
target Python;
reactor Foo(bar(0)) {
  preamble {=
    import random
  =}
  state baz
  input _in
  logical action act
  reaction(_in, act) {=
    # Body of the reaction
    self.random.seed() # Note the use of self
  =}
}
main reactor {
  foo = new Foo()
}
```

Th reactor `Foo` and its instance, `foo`, will be converted to

```python
# src-gen/XXX/XXX.py
...
# Python class for reactor Foo
class _Foo:

    # From the preamble, verbatim:
    import random
    def __init__(self, **kwargs):
        #Define parameters and their default values
        self._bar = 0
        # Handle parameters that are set in instantiation
        self.__dict__.update(kwargs)

        # Define state variables
        self.baz = None

    @property
    def bar(self):
        return self._bar

    def reaction_function_0(self , _in, act):
        # Body of the reaction
        self.random.seed() # Note the use of self
        return 0


# Instantiate classes
xxx_lf = [None] * 1
xxx_foo_lf = [None] * 1
# Start initializing XXX of class XXX
for xxx_i in range(1):
    bank_index = xxx_i
    xxx_lf[0] = _XXX(
        _bank_index = 0,
    )
    # Start initializing XXX.foo of class Foo
    for xxx_foo_i in range(1):
        bank_index = xxx_foo_i
        xxx_foo_lf[0] = _Foo(
            _bank_index = 0,
            _bar=0,
        )
...
```

### The generated LinguaFrancaXXX Python module (a C extension module)

The rest of the files in `src-gen/XXX` form a [Python C extension
module](https://docs.python.org/3/extending/building.html#building-c-and-c-extensions)
called `LinguaFrancaXXX` that can be built by executing `python3 setup.py build_ext --inplace` in the `src-gen/XXX/` folder. In this case, Python will
read the instructions in the `src-gen/XXX/setup.py` file and build a
`LinguaFrancaXXX` module in `src-gen/XXX/`. The `--inplace` flag puts the
compiled extension (the `LinguaFrancaXXX*.so` in the example above) in the
`src-gen` directory alongside the `XXX.py` file.

As mentioned before, the LinguaFrancaXXX module is separate from
`src-gen/XXX/XXX.py` but interacts with it. Next, we explain this interaction.

### Interactions between XXX.py and LinguaFrancaXXX

The LinguaFrancaXXX module is imported in `src-gen/XXX/XXX.py`:

```python
from LinguaFrancaXXX import *
```

This is done to enable the main function in `src-gen/XXX/XXX.py` to make a call to the `start()` function, which is part of the generated (and installed) `LinguaFrancaXXX` module. This function will start the main event handling loop of the C runtime.

From then on, `LinguaFrancaXXX` will call reactions that are defined in `src-gen/XXX/XXX.py` when needed.

### The LinguaFrancaBase package

[LinguaFrancaBase](https://pypi.org/project/LinguaFrancaBase/) is a package that contains several helper methods and definitions that are necessary for the Python target to work. This module is installable via `python3 -m pip install LinguaFrancaBase` but is automatically installed if needed during the installation of `LinguaFrancaXXX`. The source code of this package can be found [on GitHub](https://github.com/lf-lang/reactor-c-py).

This package's modules are imported in the `XXX.py` program:

```python
from LinguaFrancaBase.constants import * #Useful constants
from LinguaFrancaBase.functions import * #Useful helper functions
from LinguaFrancaBase.classes import * #Useful classes
```

### Already imported Python modules

The following packages are already imported and thus do not need to be re-imported by the user:

```python
import os
import sys
import copy
```

````

