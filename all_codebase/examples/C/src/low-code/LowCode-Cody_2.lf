/**
 * This is a first experiment with using ChatGPT to generate reaction code. The prompt given to
 * ChatGPT has three parts:
 *
 * 1. A generic part that is the same for all uses. 2. A reaction-specific part that can be
 * automatically generated. 3. A user-written part that describes what the reaction should do.
 *
 * Concatenate these three parts and submit it to ChatGPT. A typical response ignores the first
 * paragraph instructions and generates something with the following structure:
 * ```
 * #include <stuff>
 * define functions and maybe structs
 * 
 * void yourCode() {
 *   reaction body
 * }
 * ```

 *
 * The stuff within the yourCode() function can often be just pasted into the reaction body.
 * Sometimes it needs small corrections.
 *
 * The stuff outside the yourCode() function should be put into a preamble. An example is given here
 * with verbatim output from ChatGPT.
 *
 * This work is inspired by the following paper, which shows how effective the three-part prompt
 * approach can be:
 *
 * [1] Daniel Busch, Gerrit Nolte, Alexander Bainczyk, and Bernhard Steffen, "ChatGPT in the Loop: A
 * Natural Language Extension for Domain-Specific Modeling Languages," AISoLA, Crete, Greece, Oct.
 * 23-28, 2023.
 *
 * @author Edward A. Lee
 */
/**
 * Generic prompt (omitting state variables, lf_request_stop(), and some other stuff):
 *
 * Start a new conversation.
 *
 * Please generate a code fragment. Generate code only, with comments if appropriate, but no
 * additional text. Your code should be a fragment to be later inserted into a procedure. There
 * should be no main function and no surrounding function definition.
 *
 * Your code will execute at a logical time that is returned by the function lf_time_logical, which
 * takes no arguments. It will execute at a physical time that is returned by the function
 * lf_time_physical, which also takes no arguments. Both functions return a positive value of type
 * interval_t, which is an alias for a long long that represents time in nanoseconds (Unix Epoch
 * time).
 *
 * The code may read inputs from input ports. Each port has a type. The environment around your code
 * will provide a pointer that you can use to refer the port. The pointer points to a C struct that
 * has a value field whose type matches that of the port. The struct also has an is_present field
 * that is true if the input is present at the current logical time. If the port type is an array
 * (for example, int[]), then the length of the array is available in a field called length.
 *
 * The code may produce scalar outputs by calling the function lf_set, which takes two arguments:
 * the output port on which to produce the output and the value to be produced. The environment
 * around your code will provide a variable that refers to the output port.
 *
 * If the output port has an array type, such as int[], then you can produce an array output using
 * the function lf_set_array, which takes three arguments: the output port variable, the array
 * (which must be dynamically allocated using malloc or calloc), and the length of the array. Your
 * code should not free the memory you have dynamically allocated.
 */
target C

reactor RandomArray {
  output out: int[]

  /**
   * Automatically generated prompt:
   *
   * Your code should be written in C. Your code will be invoked once only at the start of
   * execution. Your code may produce an array output on the port variable out, which has type
   * int[].
   */
  /**
   * User generated prompt:
   *
   * Please provide code that produces an array of length 10 whose entries are random integers
   * between 0 and 100.
   */
  preamble {=
    // GENERATED BY Cody, after a second try. In the first try, it didn't generate the includes and the srand() function:
    #include <stdlib.h>
    #include <time.h>

    // Seed random number generator
    srand(time(NULL));

    // Generate array
    int length = 10;
    int* array = (int*) malloc(length * sizeof(int));

    for (int i = 0; i < length; i++) {
      array[i] = rand() % 101; // Random int between 0 and 100
    }

    // Set output
    lf_set_array(out, array, length);
  =}
}

reactor Sort {
  input in: int[]
  output out: int[]

  /**
   * Automatically generated prompt:
   *
   * Your code should be written in C. This code will be invoked each time an input is present on
   * the port variable in. Your code may produce an array output on the port variable out, which has
   * type int[].
   */
  /**
   * User generated prompt:
   *
   * Please provide code that reads an array on input in, sorts it into a new array, and outputs it
   * on output out.
   */
  preamble {=
        // GENERATED BY Cody:

        // Comparison function for qsort
    int compareInts(const void* a, const void* b) {
      return (*(int*)a - *(int*)b);
    }
  =}

  reaction(in) -> out {=
        // GENERATED BY Cody
        reaction(in) -> out {

    if (in->is_present) {

      // Get length of input array
      int length = in->length;

      // Allocate memory for output array
      int* sorted = (int*) malloc(length * sizeof(int));

      // Copy input to output
      for (int i = 0; i < length; i++) {
        sorted[i] = in->value[i];
      }

      // Sort the output array
      qsort(sorted, length, sizeof(int), compareInts);

      // Set the output
      lf_set_array(out, sorted, length);

    }
  =}
}

// Hand written (copied from example in the documentation):
reactor Print {
  input in: int[]

  reaction(in) {=
    printf("Received: [");
    for (int i = 0; i < in->length; i++) {
      if (i > 0) printf(", ");
      printf("%d", in->value[i]);
    }
    printf("]\n");
  =}
}

main reactor {
  r = new RandomArray()
  s = new Sort()
  p = new Print()
  r.out -> s.in
  s.out -> p.in
}
