/**
 * This is a first experiment with using ChatGPT to generate reaction code. The prompt given to
 * ChatGPT has three parts:
 *
 * 1. A generic part that is the same for all uses. 2. A reaction-specific part that can be
 * automatically generated. 3. A user-written part that describes what the reaction should do.
 *
 * Concatenate these three parts and submit it to ChatGPT. A typical response ignores the first
 * paragraph instructions and generates something with the following structure:
 * ```
 * #include <stuff>
 * define functions and maybe structs
 * 
 * void yourCode() {
 *   reaction body
 * }
 * ```

 *
 * The stuff within the yourCode() function can often be just pasted into the reaction body.
 * Sometimes it needs small corrections.
 *
 * The stuff outside the yourCode() function should be put into a preamble. An example is given here
 * with verbatim output from ChatGPT.
 *
 * This work is inspired by the following paper, which shows how effective the three-part prompt
 * approach can be:
 *
 * [1] Daniel Busch, Gerrit Nolte, Alexander Bainczyk, and Bernhard Steffen, "ChatGPT in the Loop: A
 * Natural Language Extension for Domain-Specific Modeling Languages," AISoLA, Crete, Greece, Oct.
 * 23-28, 2023.
 *
 * @author Edward A. Lee
 */
/**
 * Generic prompt (omitting state variables, lf_request_stop(), and some other stuff):
 *
 * Start a new conversation.
 *
 * Please generate a code fragment. Generate code only, with comments if appropriate, but no
 * additional text. Your code should be a fragment to be later inserted into a procedure. There
 * should be no main function and no surrounding function definition.
 *
 * Your code will execute at a logical time that is returned by the function lf_time_logical, which
 * takes no arguments. It will execute at a physical time that is returned by the function
 * lf_time_physical, which also takes no arguments. Both functions return a positive value of type
 * interval_t, which is an alias for a long long that represents time in nanoseconds (Unix Epoch
 * time).
 *
 * The code may read inputs from input ports. Each port has a type. The environment around your code
 * will provide a pointer that you can use to refer the port. The pointer points to a C struct that
 * has a value field whose type matches that of the port. The struct also has an is_present field
 * that is true if the input is present at the current logical time. If the port type is an array
 * (for example, int[]), then the length of the array is available in a field called length.
 *
 * The code may produce scalar outputs by calling the function lf_set, which takes two arguments:
 * the output port on which to produce the output and the value to be produced. The environment
 * around your code will provide a variable that refers to the output port.
 *
 * If the output port has an array type, such as int[], then you can produce an array output using
 * the function lf_set_array, which takes three arguments: the output port variable, the array
 * (which must be dynamically allocated using malloc or calloc), and the length of the array. Your
 * code should not free the memory you have dynamically allocated.
 */
target C

reactor RandomArray {
  output out: int[]

  /**
   * Automatically generated prompt:
   *
   * // Read input from port1 if present if (port1.is_present) { int inputValue =
   * *((int*)port1.value); Perform operations with inputValue }
   *
   * Read input from port2 if present if (port2.is_present) { float floatValue =
   * *((float*)port2.value); Perform operations with floatValue }
   *
   * Calculate logical and physical times interval_t logicalTime = lf_time_logical(); interval_t
   * physicalTime = lf_time_physical();
   *
   * Perform operations based on logical and physical times ...
   *
   * Produce scalar output on outputPort1 lf_set(outputPort1, outputValue1);
   *
   * Produce array output on outputPort2 int arrayLength = 5; // Replace with actual length int*
   * outputArray = (int*)malloc(arrayLength * sizeof(int)); Initialize outputArray with values
   * lf_set_array(outputPort2, outputArray, arrayLength);
   */
  /**
   * User generated prompt:
   *
   * Please provide code that produces an array of length 10 whose entries are random integers
   * between 0 and 100.
   */
  preamble {=
        // GENERATED BY ChatGPT:
        #include <stdlib.h>
        #include <time.h>

       // Define a function to generate a random integer between min and max (inclusive).
    int generateRandomInt(int min, int max) {
        return min + rand() % (max - min + 1);
    }
  =}

  reaction(startup) -> out {=
    // GENERATED BY ChatGPT:
    // Seed the random number generator with the current time
    srand((unsigned int)lf_time_physical());

    // Allocate memory for the output array.
    int length = 10;
    int* resultArray = (int*)malloc(length * sizeof(int));

    if (resultArray != NULL) {
        // Generate random integers and store them in the array.
        for (int i = 0; i < length; i++) {
            resultArray[i] = generateRandomInt(0, 100);
        }

        // Produce the array as an output.
        lf_set_array(outputPort, resultArray, length);
    }
  =}
}

reactor Sort {
  input in: int[]
  output out: int[]

  /**
   * Automatically generated prompt:
   *
   * Your code should be written in C. This code will be invoked each time an input is present on
   * the port variable in. Your code may produce an array output on the port variable out, which has
   * type int[].
   */
  /**
   * User generated prompt:
   *
   * Please provide code that reads an array on input in, sorts it into a new array, and outputs it
   * on output out.
   */
  preamble {=
        // GENERATED BY ChatGPT:
        #include <stdlib.h>

        // Comparator function for sorting integers in ascending order.
    int compareIntegers(const void* a, const void* b) {
        return (*(int*)a - *(int*)b);
    }
  =}

  reaction(in) -> out {=
    // Check if input is present and not NULL.
    if (in != NULL && in->is_present) {
        // Get the length of the input array.
        int length = in->length;

        // Allocate memory for a new array.
        int* sortedArray = (int*)malloc(length * sizeof(int));

        if (sortedArray != NULL) {
            // Copy the input array into the new array.
            for (int i = 0; i < length; i++) {
                sortedArray[i] = in->value[i];
            }

            // Sort the new array in ascending order.
            qsort(sortedArray, length, sizeof(int), compareIntegers);

            // Produce the sorted array as an output.
            lf_set_array(out, sortedArray, length);
        }
    }
  =}
}

// Hand written (copied from example in the documentation):
reactor Print {
  input in: int[]

  reaction(in) {=
    printf("Received: [");
    for (int i = 0; i < in->length; i++) {
      if (i > 0) printf(", ");
      printf("%d", in->value[i]);
    }
    printf("]\n");
  =}
}

main reactor {
  r = new RandomArray()
  s = new Sort()
  p = new Print()
  r.out -> s.in
  s.out -> p.in
}
